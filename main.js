// main.js - Main p5.js sketch using modules

// Import visualization modules
import FlowerVisualization from './flower.js';
import LorenzVisualization from './lorenz.js';
import LSystemVisualization from './lsystem.js';

const sketch = (p) => {

    // --- Global State ---
    let currentVizKey = 'about';
    let animateViz = false;
    let animationSpeed = 1.0;
    let visualizations = {}; // Object to hold instances

    // --- DOM References ---
    let vizSelect, animateCheckbox, animSpeedSlider, animSpeedValSpan,
        vizNameSpan, vizFormulaHeaderSpan, titleContainer, animationControlsDiv,
        explanationContainerDiv, specificControlsContainer;

    // --- Content Maps (Ensure keys match dropdown values and viz objects) ---
    const vizDisplayNames = {
        about: "About", flower: "Polar Flower", lorenz: "Lorenz Attractor",
        lsystem: "L-System Generator"
    };
    const formulas = {
        about: `Select a visualization...`,
        flower: `r = <span class="variable">a</span> &sdot; cos(<span class="variable">k</span> &sdot; &theta;)`,
        lorenz: `dx/dt = &sigma;(y-x), dy/dt = x(&rho;-z)-y, dz/dt = xy-&beta;z <span class='comment'>(2D Projection)</span>`,
        lsystem: `L-System Turtle Graphics`
    };
    const explanations = {
         about: `Created by Joshua Prull, 2025. Select a visualization from the dropdown.`,
         flower: `<h3>Polar Flower (Rose Curve)</h3><p>This shape is generated by a polar equation where the distance from the center (radius, <code>r</code>) depends on the angle (<code>&theta;</code>). The formula shown is a common way to generate flower-like patterns.</p><p><strong>Parameters:</strong></p><ul><li><span class="variable">a</span> (Amplitude): Controls the overall size of the petals.</li><li><span class="variable">k</span> (Petal Factor): Determines the number and shape of petals. If <span class="variable">k</span> is an integer, the flower has <span class="variable">k</span> petals (if <span class="variable">k</span> is odd) or 2<span class="variable">k</span> petals (if <span class="variable">k</span> is even). If <span class="variable">k</span> is non-integer, more complex patterns emerge.</li></ul>`,
         lorenz: `<h3>Lorenz Attractor</h3><p>This is a famous example of a <strong>dynamic system</strong> exhibiting chaotic behavior, first described by Edward Lorenz in 1963. It arises from a simplified model of atmospheric convection.</p><p>The visualization shows the path (or trajectory) of the system's state over time in a 3D space (represented here by a 2D projection). Even though the governing equations are simple and deterministic (no randomness), the path is highly sensitive to the starting point (the "butterfly effect") and never exactly repeats, tracing out a complex, fractal structure known as a <strong>strange attractor</strong>.</p><p><strong>Why it matters:</strong> The Lorenz system was seminal in the development of <strong>chaos theory</strong>. It demonstrated how complex, unpredictable behavior can emerge from simple, non-linear deterministic rules, impacting fields from weather prediction to biology and economics.</p><p><strong>Parameters:</strong></p><ul><li><span class="variable">&sigma;</span> (Sigma): Related to fluid viscosity and thermal diffusivity (Prandtl number). Affects the shape and contraction rate of the attractor. The classic value is 10.</li><li><span class="variable">&rho;</span> (Rho): Related to the temperature difference driving the convection (Rayleigh number). Primary control for chaotic behavior. Chaos around <span class="variable">&rho;</span> > 24.74. Classic value is 28.</li><li><span class="variable">&beta;</span> (Beta): Related to the physical dimensions. Influences shape and stability. Classic value is 8/3.</li><li><code>Points</code>: Number of steps calculated.</li><li><code>Time Step (dt)</code>: Calculation increment size. Smaller is more accurate but slower.</li></ul>`,
         lsystem: `<h3>L-System Generator</h3><p>L-Systems (Lindenmayer Systems) are string rewriting systems used to model biological growth and generate fractals. They start with an initial string (axiom) and iteratively replace characters based on production rules.</p><p>The resulting string is then interpreted as instructions for 'turtle graphics': <code>F</code> means move forward drawing a line, <code>+</code> means turn left by a set angle, <code>-</code> means turn right. Other common symbols include <code>[</code> (push current state: position & angle) and <code>]</code> (pop state), allowing for branching structures.</p><p>This creates intricate, often self-similar patterns resembling natural forms.</p><p><strong>Parameters:</strong></p><ul><li><span class="variable">Preset</span>: Selects predefined axioms, rules, and suggested starting angles (like Koch Snowflake, Dragon Curve, Fractal Plant). The angle slider can override the preset's suggestion.</li><li><span class="variable">Iterations</span>: The number of times the rewriting rules are applied. Higher iterations create more complex and detailed fractals but take longer to calculate and draw.</li><li><span class="variable">Angle</span>: The angle (in degrees) the turtle turns for '+' and '-' commands. Different angles produce vastly different shapes.</li><li><span class="variable">Segment Length</span>: The base length of the line segment drawn for each 'F' command (may shrink in deeper iterations).</li></ul><p>When animated, the path is drawn segment by segment, revealing the construction process.</p>`
    };


    p.setup = () => {
        console.log("Main setup running...");
        let canvasContainer = p.select('#canvasContainer'); let controlsContainer = p.select('#controls'); titleContainer = p.select('#vizTitleContainer');
        let availableWidth = p.windowWidth - (controlsContainer ? controlsContainer.width : 300) - 60; let canvasWidth = Math.max(400, availableWidth);
        let availableHeight = p.windowHeight - (titleContainer ? titleContainer.height : 50) - 80; let canvasHeight = Math.min(500, availableHeight);
        let canvas = p.createCanvas(canvasWidth, canvasHeight); canvas.parent('canvasContainer');

        // Get General DOM elements
        vizSelect = p.select('#vizSelect'); animateCheckbox = p.select('#animateCheck'); animSpeedSlider = p.select('#animSpeed'); animSpeedValSpan = p.select('#animSpeedVal');
        vizNameSpan = p.select('#vizName'); vizFormulaHeaderSpan = p.select('#vizFormulaHeader'); animationControlsDiv = p.select('.animation-controls'); explanationContainerDiv = p.select('#explanationContainer');
        specificControlsContainer = p.select('#specificControlsContainer');

        // Instantiate Visualization Modules
        visualizations = {}; // Clear first
        try {
             visualizations['flower'] = new FlowerVisualization(p, p.select('#flowerControls'));
             visualizations['lorenz'] = new LorenzVisualization(p, p.select('#lorenzControls'));
             // visualizations['lissajous'] = new LissajousVisualization(p, p.select('#lissajousControls')); // Keep Lissajous removed unless re-added
             visualizations['lsystem'] = new LSystemVisualization(p, p.select('#lsystemControls'));
             console.log("Visualization modules instantiated:", Object.keys(visualizations));
        } catch (e) { console.error("Error instantiating visualization modules:", e); }

        // Attach Listeners to General Controls
        const addListener = (selector, event, handler) => { const elem = p.select(selector); if (elem) { elem[event](handler); } else { console.warn(`Element not found: ${selector}`); }};
        if (vizSelect) { vizSelect.changed(visualizationChanged); console.log("Dropdown listener attached."); } else { console.error("Could not find #vizSelect!"); }
        addListener('#animateCheck', 'changed', updateGeneralParams);
        addListener('#animSpeed', 'input', updateGeneralParams); // Attach listener for speed slider

        // Specific listeners are set up within the modules' constructors

        // Initial UI setup
        currentVizKey = vizSelect.value();
        updateGeneralParams(); // Set initial general param state from controls
        visualizationChanged(); // Setup UI based on initial dropdown value

        p.angleMode(p.DEGREES); p.colorMode(p.HSB, 360, 100, 100, 1);
        console.log("Main setup complete.");
    };

    p.draw = () => {
        p.background(0);
        p.push(); p.fill(0, 100, 100); p.noStroke(); p.ellipse(30, 30, 20, 20); p.pop(); // Sanity check dot

        const activeViz = visualizations[currentVizKey];

        if (activeViz?.draw) {
            // Apply centering translate for 2D visualizations that need it
            const needsCentering = (currentVizKey === 'flower' || currentVizKey === 'lsystem'); // Add other 2D keys here
            if (needsCentering) { p.push(); p.translate(p.width / 2, p.height / 2); }

            activeViz.draw({ animate: animateViz, speed: animationSpeed });

            if (needsCentering) { p.pop(); }
        } else if (currentVizKey === 'about') {
            p.push(); p.fill(0, 0, 80); p.textAlign(p.CENTER, p.CENTER); p.textSize(18);
            p.text("Select a visualization.", p.width / 2, p.height / 2); p.pop();
        } else if (currentVizKey) { // Only warn if key is not 'about' and viz not found
             console.warn("No active drawing function found for:", currentVizKey);
             p.push(); p.fill(255,0,100); p.textAlign(p.CENTER, p.CENTER); p.textSize(18);
             p.text(`Error: Viz "${currentVizKey}" not found.`, p.width / 2, p.height / 2);
             p.pop();
        }
    };

    // Handles changes to GENERAL controls (Animation checkbox, speed)
    function updateGeneralParams() {
        if (animateCheckbox) animateViz = animateCheckbox.checked(); else animateViz = false;
        if (animSpeedSlider) animationSpeed = parseFloat(animSpeedSlider.value()); else animationSpeed = 1.0;
        if (animSpeedValSpan) animSpeedValSpan.html(animationSpeed.toFixed(1));

        const activeViz = visualizations[currentVizKey];
        // Redraw if animation state changed and the current viz supports it
        if (activeViz?.isAnimatable ? activeViz.isAnimatable() : false) {
             p.redraw();
        }
    }

    // Handles Dropdown Change
    function visualizationChanged() {
        if (!vizSelect) return;
        currentVizKey = vizSelect.value();
        console.log("Viz Changed:", currentVizKey);

        const activeViz = visualizations[currentVizKey]; // Get the specific viz object
        // Use maps defined at the top level
        const displayName = vizDisplayNames[currentVizKey] || "Unknown";
        const formulaHTML = formulas[currentVizKey] || "";
        const explanationHTML = explanations[currentVizKey] || "";

        // Update Header
        if (vizNameSpan) vizNameSpan.html(displayName);
        if (vizFormulaHeaderSpan) vizFormulaHeaderSpan.html(formulaHTML);
        if (titleContainer) { titleContainer.style('display', currentVizKey === 'about' ? 'none' : 'block'); }

        // Update Explanation
        if (explanationContainerDiv) { try { explanationContainerDiv.elt.innerHTML = explanationHTML; explanationContainerDiv.style('display', (currentVizKey === 'about' || !explanationHTML) ? 'none' : 'block'); } catch (e) { console.error("Error setting explanation HTML:", e); explanationContainerDiv.elt.innerText = "Error loading explanation."; explanationContainerDiv.style('display', 'block'); } } else { console.warn("Explanation container not found"); }

        // Show/Hide Animation Controls based on module property
        const showAnim = activeViz?.isAnimatable ? activeViz.isAnimatable() : false;
        if (animationControlsDiv) { animationControlsDiv.style('display', showAnim ? 'block' : 'none'); }
        // *** Reset animation state when changing viz ***
        if (animateCheckbox) { animateCheckbox.checked(false); }
        animateViz = false;


        // Activate/Deactivate Specific Controls
        console.log("--- Activating Controls ---");
        const allVizControls = p.selectAll('.viz-controls');
        allVizControls.forEach(el => { el.removeClass('active'); }); // Hide all first
        console.log(`Attempting to select: #${currentVizKey}Controls`);
        if (currentVizKey !== 'about') {
             const activeControl = p.select('#' + currentVizKey + 'Controls');
             if (activeControl) {
                 activeControl.addClass('active');
                 console.log("Successfully activated controls:", activeControl.id());
                 // Call activate method on the specific instance if it exists
                 if (activeViz && typeof activeViz.activate === 'function') {
                     activeViz.activate();
                 }
             } else {
                 console.warn("!!! Failed to find control div with selector:", '#' + currentVizKey + 'Controls');
             }
        } else {
            console.log("Hiding all specific controls for 'about'.");
        }
        console.log("--- Finished Activating Controls ---");


        // Set flags or update sliders ONLY when switching TO the viz that needs it
        if (currentVizKey === 'lorenz' && activeViz) {
            activeViz.needsRecalculation = true; // Use the instance's flag
            // Ensure sliders reflect current state
            if (activeViz.sliderSigma) activeViz.sliderSigma.value(activeViz.sigma); // Use instance members
            if (activeViz.sliderRho) activeViz.sliderRho.value(activeViz.rho);
            if (activeViz.sliderBeta) activeViz.sliderBeta.value(activeViz.beta);
            if (activeViz.sliderSteps) activeViz.sliderSteps.value(activeViz.numSteps);
            if (activeViz.sliderDt) activeViz.sliderDt.value(activeViz.dt);
            // Update displays via the module's updateParams if needed, or ensure it was called
             if (typeof activeViz.updateParams === 'function') activeViz.updateParams();
        }
        if (currentVizKey === 'lsystem' && activeViz) {
             activeViz.needsGeneration = true; // Use instance flag
             if(typeof activeViz.resetAnimation === 'function') activeViz.resetAnimation();
             if(typeof activeViz.updateControls === 'function') activeViz.updateControls(); // Ensure sliders match state
        }

        p.redraw(); // Always request redraw after changing viz
    }

    // Removed incorrect updateParams definition from main scope
    // Parameters are updated via listeners calling module-specific updateParams

}; // *** End sketch function wrapper ***

// *** Create the main p5 instance ***
new p5(sketch);